name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      # 1️⃣ Checkout only for k8s manifests
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2️⃣ Install kubectl
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: v1.29.0

      # 3️⃣ Configure Kubernetes context securely (handles KUBE_CONFIG or KUBECONFIG, raw or base64)
      - name: Configure kubeconfig
        env:
          KUBE_CONFIG_SECRET: ${{ secrets.KUBE_CONFIG || '' }}
          KUBECONFIG_SECRET: ${{ secrets.KUBECONFIG || '' }}
        run: |
          mkdir -p ~/.kube
          set -euo pipefail

          # Prefer KUBE_CONFIG, fallback to KUBECONFIG
          if [ -n "${KUBE_CONFIG_SECRET}" ]; then
            K_CFG="${KUBE_CONFIG_SECRET}"
          elif [ -n "${KUBECONFIG_SECRET}" ]; then
            K_CFG="${KUBECONFIG_SECRET}"
          else
            echo "ERROR: No kubeconfig secret found. Set KUBE_CONFIG or KUBECONFIG in repository secrets."
            exit 1
          fi

          # Try to detect base64 and decode, otherwise write raw
          if printf '%s' "$K_CFG" | base64 --decode >/dev/null 2>&1; then
            printf '%s' "$K_CFG" | base64 --decode > ~/.kube/config
          else
            printf '%s' "$K_CFG" > ~/.kube/config
          fi
          chmod 600 ~/.kube/config

          echo "kubectl client version:"
          kubectl version --client --short || true

          echo "Checking cluster access..."
          if ! kubectl cluster-info >/dev/null 2>&1; then
            echo "ERROR: Unable to contact the Kubernetes API server."
            echo "Kubeconfig server entries (no secrets printed):"
            grep -E "server:" -n ~/.kube/config || true
            exit 1
          fi

      # 4️⃣ Create / update DockerHub imagePullSecret
      - name: Create DockerHub image pull secret
        run: |
          kubectl create secret docker-registry dockerhub-secret \
            --docker-username=${{ secrets.DOCKERHUB_USERNAME }} \
            --docker-password=${{ secrets.DOCKERHUB_TOKEN }} \
            --docker-server=https://index.docker.io/v1/ \
            --dry-run=client -o yaml \
          | kubectl apply --validate=false -f -

      # 5️⃣ Deploy application manifests
      - name: Render k8s manifests with DockerHub username and apply
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          set -euo pipefail
          # replace placeholder in deployment.yml with the DockerHub username
          sed "s|<YOUR_DOCKERHUB_USERNAME>|${DOCKERHUB_USERNAME}|g" k8s/deployment.yml > k8s/deployment.rendered.yml
          # apply rendered deployment and any other manifests
          kubectl apply --validate=false -f k8s/deployment.rendered.yml
          # apply remaining manifests if present
          if [ -d k8s ] && ls k8s/*.yml 1>/dev/null 2>&1; then
            for f in k8s/*.yml; do
              if [ "$f" != "k8s/deployment.rendered.yml" ]; then
                kubectl apply --validate=false -f "$f"
              fi
            done
          fi

      # 6️⃣ Verify deployment rollout
      - name: Verify rollout
        run: |
          kubectl rollout status deployment/transaction-risk-service --timeout=120s
          kubectl get pods -o wide

      # 7️⃣ Runtime validation (dummy DAST)
      - name: Runtime health check
        run: |
          kubectl port-forward svc/transaction-risk-service 8080:8080 &
          sleep 10
          curl -f http://localhost:8080/actuator/health
